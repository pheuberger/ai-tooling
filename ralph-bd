#!/usr/bin/env bash
# ralph-bd.sh — Ralph Loop for beads-driven autonomous coding
#
# Spawns a fresh Claude Code instance per ready bead. Each instance gets
# clean context — no conversation history carries over. State lives in
# the filesystem and git, not in the LLM's memory. This sidesteps context
# degradation by treating every iteration as a brand-new session.
#
# Usage: ./ralph-bd [options]
#   --max-iterations N   Maximum total iterations (default: 50)
#   --max-retries N      Retries per bead on failure (default: 3)
#   --model MODEL        Force ALL agents to this model (overrides per-agent models)
#   --beads ID[,ID,...]  Only process these beads, in order (skip bd ready)
#   --respect-deps       With --beads: skip beads whose dependencies aren't closed yet
#   --type TYPE          Filter ready beads by issue_type (feature|bug|task)
#   --priority N         Only pick beads with priority <= N (0=critical … 4=backlog)
#   --owner NAME         Only pick beads owned by NAME
#   --label LABEL        Filter ready beads by label
#   --from-plan FILE     Decompose a plan file into label-grouped tasks, then work them
#   --test-cmd CMD       Run CMD as post-loop test gate; files bead + exits 1 on failure
#
# Configuration files (optional):
#   .ralphrc             Sourced from project root before CLI args are parsed.
#                        Set any of: MAX_ITERATIONS, MAX_RETRIES, MODEL,
#                        WORKER_MODEL, REVIEWER_MODEL, COMMIT_MODEL,
#                        FINAL_REVIEW_MODEL, LEAD_MODEL, SPEC_MODEL, SUMMARY_MODEL,
#                        FILTER_TYPE, FILTER_PRIORITY, FILTER_OWNER,
#                        FILTER_LABEL, TEST_CMD, LOG_DIR, RALPH_RULES_FILE.
#                        CLI flags override values set here.
#   .ralph-rules.md      Extra instructions injected into the agent prompt as a
#                        "## Project Rules" section. Use for ralph-specific rules
#                        that don't belong in AGENTS.md or CLAUDE.md. Silently
#                        skipped if absent. Path configurable via RALPH_RULES_FILE.
#
# Requires: claude (Claude Code CLI), bd (beads), jq, git
#
# References:
#   https://github.com/snarktank/ralph
#   https://medium.com/@tentenco/what-is-ralph-loop-a-new-era-of-autonomous-coding-96a4bb3e2ac8

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROMPTS_DIR="${PROMPTS_DIR:-$SCRIPT_DIR/prompts}"

# Colors
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'
C_CYAN='\033[36m'
C_GREEN='\033[32m'
C_YELLOW='\033[33m'
C_MAGENTA='\033[35m'
C_BLUE='\033[34m'
C_RED='\033[31m'
C_WHITE='\033[97m'

ts()         { printf '%s' "$(date '+%Y-%m-%d %H:%M:%S')"; }
log()        { echo -e "${C_DIM}[$(ts)]${C_RESET} $*"; }
bd_sync()    { bd sync 2>/dev/null || true; }
bead_field() { echo "$1" | jq -r ".[0].$2 // \"$3\""; }
phase()      { echo -e "\n${C_BOLD}${1}--- ${2} ---${C_RESET}"; }
divider()    { echo -e "${C_DIM}$(printf '%.0s─' {1..65})${C_RESET}"; }
slugify()    { echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g; s/--*/-/g; s/^-//; s/-$//' | cut -c1-50; }

# render_prompt <template_file> [VAR1 VAR2 ...]
# Reads a markdown template, processes {{#IF VAR}}/{{/IF VAR}} conditionals,
# then runs envsubst with an explicit variable list. No eval — safe by design.
render_prompt() {
  local template="$1"; shift
  [[ -f "$template" ]] || { echo "Missing prompt template: $template" >&2; return 1; }

  local content
  content=$(<"$template")

  # Process {{#IF VAR}}...{{/IF VAR}} conditional blocks.
  # If the named env var is non-empty, keep the block contents; otherwise remove the block.
  while [[ "$content" =~ \{\{#IF\ ([A-Z_]+)\}\} ]]; do
    local var_name="${BASH_REMATCH[1]}"
    local var_val="${!var_name:-}"
    if [[ -n "$var_val" ]]; then
      # Keep block contents, remove markers
      content=$(echo "$content" | sed "/{{#IF ${var_name}}}/d; /{{\/IF ${var_name}}}/d")
    else
      # Remove entire block including markers
      content=$(echo "$content" | sed "/{{#IF ${var_name}}}/,/{{\/IF ${var_name}}}/d")
    fi
  done

  # Build envsubst variable list: $VAR1 $VAR2 ...
  local varlist=""
  for v in "$@"; do varlist="$varlist \${$v}"; done

  echo "$content" | envsubst "$varlist"
}

# True if there are unstaged, staged, or untracked changes outside .ralph-logs/ and .beads/
has_code_changes() {
  git diff --quiet -- ':!.ralph-logs' ':!.beads' 2>/dev/null            || return 0
  git diff --cached --quiet -- ':!.ralph-logs' ':!.beads' 2>/dev/null   || return 0
  [[ -z "$(git ls-files --others --exclude-standard -- ':!.ralph-logs' ':!.beads' 2>/dev/null)" ]] || return 0
  return 1
}

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
MAX_ITERATIONS=50
MAX_RETRIES=3
MODEL=""              # global override — forces all agents to this model
LEAD_MODEL=""         # lead agent (plan decomposition) — default: opus
SPEC_MODEL=""         # spec reviewer — default: opus
WORKER_MODEL=""       # coding worker — default: sonnet
COMMIT_MODEL=""       # commit agent — default: haiku
REVIEWER_MODEL=""     # intermittent code reviewer — default: sonnet
FINAL_REVIEW_MODEL="" # final parallel review personas — default: opus
SUMMARY_MODEL=""      # post-run summary — default: haiku
BEAD_IDS=""           # comma-separated explicit bead list (--beads mode only)
PLAN_LABEL=""         # label slug generated from --from-plan title
EXPLICIT_MODE=false   # set when --beads is used (prevents fallback to bd ready)
RESPECT_DEPS=false    # with --beads: skip beads whose deps aren't closed
FILTER_TYPE=""        # filter by issue_type (feature|bug|task)
FILTER_PRIORITY=""    # only beads with priority <= this value (0=critical … 4=backlog)
FILTER_OWNER=""       # only beads owned by this name
FILTER_LABEL=""       # filter by label
PLAN_FILE=""          # --from-plan: plan file to decompose into beads
TEST_CMD=""           # --test-cmd: command to run as post-loop test gate
LOG_DIR=".ralph-logs"
RALPH_RULES_FILE=".ralph-rules.md"

# Source per-project config (CLI flags override)
if [[ -f ".ralphrc" ]]; then
  # shellcheck source=/dev/null
  source ".ralphrc"
fi

SKIP_FILE="$LOG_DIR/.skipped"

while [[ $# -gt 0 ]]; do
  case $1 in
    --max-iterations) MAX_ITERATIONS="$2"; shift 2 ;;
    --max-retries)    MAX_RETRIES="$2"; shift 2 ;;
    --model)          MODEL="$2"; shift 2 ;;
    --beads)          BEAD_IDS="$2"; EXPLICIT_MODE=true; shift 2 ;;
    --respect-deps)   RESPECT_DEPS=true; shift ;;
    --type)           FILTER_TYPE="$2"; shift 2 ;;
    --priority)       FILTER_PRIORITY="$2"; shift 2 ;;
    --owner)          FILTER_OWNER="$2"; shift 2 ;;
    --label)          FILTER_LABEL="$2"; shift 2 ;;
    --from-plan)      PLAN_FILE="$2"; shift 2 ;;
    --test-cmd)       TEST_CMD="$2"; shift 2 ;;
    -h|--help)        sed -n '/^# Usage/,/^$/p' "$0" | sed 's/^# \?//'; exit 0 ;;
    *)                echo "Unknown option: $1" >&2; exit 1 ;;
  esac
done

# Read plan file early — before untracked-file stashing moves it away
plan_title=""
plan_body=""
if [[ -n "$PLAN_FILE" ]]; then
  if [[ ! -f "$PLAN_FILE" ]]; then
    echo "Plan file not found: $PLAN_FILE" >&2; exit 1
  fi
  plan_title=$(head -1 "$PLAN_FILE" | sed 's/^#* *//')
  plan_body=$(tail -n +2 "$PLAN_FILE")
fi

# ---------------------------------------------------------------------------
# Preflight
# ---------------------------------------------------------------------------
for cmd in claude bd jq git envsubst; do
  command -v "$cmd" >/dev/null 2>&1 || { echo "Required: $cmd" >&2; exit 1; }
done

git diff --quiet --cached 2>/dev/null || { echo "Staged changes exist. Commit or stash first." >&2; exit 1; }

# Move pre-existing untracked files (PLAN.md, SPEC.md, etc.) out of the
# working tree so git add -A inside the loop doesn't pick them up.
# We can't use git stash because it would also revert unstaged tracked
# changes in .beads/, breaking bd ready.
STASH_DIR=""
untracked=$(git ls-files --others --exclude-standard -- ':!.beads' ':!.ralph-logs' 2>/dev/null)
if [[ -n "$untracked" ]]; then
  STASH_DIR=$(mktemp -d /tmp/ralph-stash.XXXXXX)
  echo "$untracked" | while IFS= read -r f; do
    mkdir -p "$STASH_DIR/$(dirname "$f")"
    mv "$f" "$STASH_DIR/$f"
  done
  log "Shelved $(echo "$untracked" | wc -l | tr -d ' ') untracked file(s) to $STASH_DIR"
fi

mkdir -p "$LOG_DIR"
: > "$SKIP_FILE"

# Stream filter — extracts readable progress from stream-json output
ralph_stream_filter() {
  jq --unbuffered -r '
    if .type == "assistant" then
      [.message.content[]? |
        if .type == "text" then .text
        elif .type == "tool_use" then
          (.input // {}) as $in |
          (.name as $n |
            if   $n == "Bash"   then $in.command // ""
            elif $n == "Edit"   then $in.file_path // ""
            elif $n == "Read"   then $in.file_path // ""
            elif $n == "Write"  then $in.file_path // ""
            elif $n == "Grep"   then ($in.pattern // "") + " " + ($in.path // "")
            elif $n == "Glob"   then $in.pattern // ""
            else "" end
          ) as $detail |
          "\u001b[36m>>> " + .name + "\u001b[2m " + ($detail | .[0:120]) + "\u001b[0m"
        else empty end
      ] | join("\n") | select(length > 0)
    elif .type == "result" then
      "\u001b[2m--- " + .subtype + " | " + (.duration_ms | tostring) + "ms | $" + (.total_cost_usd | tostring) + " ---\u001b[0m"
    else empty end
  ' 2>/dev/null
}

iteration=0

# Common claude flags — shared by all agent invocations
claude_flags=(--print --dangerously-skip-permissions)

# Per-agent model defaults — global MODEL overrides everything
LEAD_MODEL="${MODEL:-${LEAD_MODEL:-claude-opus-4-6}}"
SPEC_MODEL="${MODEL:-${SPEC_MODEL:-claude-opus-4-6}}"
WORKER_MODEL="${MODEL:-${WORKER_MODEL:-claude-sonnet-4-6}}"
COMMIT_MODEL="${MODEL:-${COMMIT_MODEL:-claude-haiku-4-5-20251001}}"
REVIEWER_MODEL="${MODEL:-${REVIEWER_MODEL:-claude-sonnet-4-6}}"
FINAL_REVIEW_MODEL="${MODEL:-${FINAL_REVIEW_MODEL:-claude-opus-4-6}}"
SUMMARY_MODEL="${MODEL:-${SUMMARY_MODEL:-claude-haiku-4-5-20251001}}"

# Run claude with a specific model: claude_as <model> [extra-args...]
claude_as() {
  local model="$1"; shift
  claude "${claude_flags[@]}" --model "$model" "$@"
}

log "Ralph Loop starting (max_iterations=$MAX_ITERATIONS, max_retries=$MAX_RETRIES)"
log_opt() { [[ -n "${2:-}" ]] && log "  $1: $2" || true; }
[[ -f ".ralphrc" ]]          && log "  Config: .ralphrc loaded"
[[ -f "$RALPH_RULES_FILE" ]] && log "  Rules: $RALPH_RULES_FILE loaded"
log_opt "Plan"            "$PLAN_FILE"
log_opt "Beads"           "$BEAD_IDS"
log_opt "Filter type"     "$FILTER_TYPE"
log_opt "Filter priority" "${FILTER_PRIORITY:+<= $FILTER_PRIORITY}"
log_opt "Filter owner"    "$FILTER_OWNER"
log_opt "Filter label"    "$FILTER_LABEL"
log_opt "Test cmd"        "$TEST_CMD"
[[ "$RESPECT_DEPS" == true ]] && log "  Respect deps: yes (blocked beads deferred)" || true
if [[ -n "$MODEL" ]]; then
  log "  Model (all agents): $MODEL"
else
  log "  Models: worker=$WORKER_MODEL  reviewer=$REVIEWER_MODEL  commit=$COMMIT_MODEL"
  log "          final-review=$FINAL_REVIEW_MODEL"
  [[ -n "$PLAN_FILE" ]] && log "          lead=$LEAD_MODEL  spec=$SPEC_MODEL" || true
  log "          summary=$SUMMARY_MODEL"
fi
divider

# Load project-specific rules once (injected into worker prompts)
project_rules=""
[[ -f "$RALPH_RULES_FILE" ]] && project_rules=$(<"$RALPH_RULES_FILE")

# Cost tracking — associative array by agent type
declare -A AGENT_COSTS
extract_cost() {
  local agent_type="$1" log_file="$2"
  local cost
  cost=$(jq -r 'select(.type == "result") | .total_cost_usd // 0' "$log_file" 2>/dev/null | tail -1)
  if [[ -n "$cost" && "$cost" != "0" && "$cost" != "null" ]]; then
    AGENT_COSTS[$agent_type]=$(echo "${AGENT_COSTS[$agent_type]:-0} + $cost" | bc 2>/dev/null || echo "${AGENT_COSTS[$agent_type]:-0}")
  fi
}

# ---------------------------------------------------------------------------
# --from-plan: decompose a plan file into beads, then fall through to loop
# ---------------------------------------------------------------------------
if [[ -n "$PLAN_FILE" ]]; then
  # plan_title and plan_body were read before stashing (see above)

  # Derive a label slug from the plan title for grouping
  PLAN_LABEL=$(slugify "$plan_title")
  [[ -z "$PLAN_LABEL" ]] && { echo "Could not generate label from plan title: $plan_title" >&2; exit 1; }
  [[ -n "$FILTER_LABEL" ]] && log "  Note: --label '$FILTER_LABEL' overridden by plan label '$PLAN_LABEL'"
  FILTER_LABEL="$PLAN_LABEL"
  log "Plan label: $PLAN_LABEL"

  # --- Phase 1: Decompose epic into tasks ---
  log "Lead: decomposing into tasks..."
  lead_log="$LOG_DIR/lead-$(date '+%H%M%S').log"

  claude_as "$LEAD_MODEL" --output-format stream-json --verbose -p "$(
    export PLAN_TITLE="$plan_title" PLAN_BODY="$plan_body" PLAN_LABEL="$PLAN_LABEL"
    render_prompt "$PROMPTS_DIR/lead.md" PLAN_TITLE PLAN_BODY PLAN_LABEL
  )" 2>&1 | tee "$lead_log" | ralph_stream_filter || true
  extract_cost "lead" "$lead_log"
  bd_sync
  log "Lead: done. See $lead_log"

  # --- Phase 2: Validate specs ---
  log "Validating specs..."
  spec_log="$LOG_DIR/spec-review-$(date '+%H%M%S').log"
  children_json=$(bd list --label "$PLAN_LABEL" --status open --json --limit 0 2>/dev/null) || children_json="[]"

  claude_as "$SPEC_MODEL" --output-format stream-json --verbose -p "$(
    export CHILDREN_JSON="$children_json"
    render_prompt "$PROMPTS_DIR/spec-review.md" CHILDREN_JSON
  )" 2>&1 | tee "$spec_log" | ralph_stream_filter || true
  extract_cost "spec" "$spec_log"
  bd_sync
  log "Spec review: done. See $spec_log"

  # FILTER_LABEL is set — fall through into the main worker+reviewer loop
fi

PRE_LOOP_HEAD=$(git rev-parse HEAD)

# ---------------------------------------------------------------------------
# Main loop — runs as long as there are unblocked beads
# ---------------------------------------------------------------------------
while true; do
  # -----------------------------------------------------------------------
  # Pick next bead — explicit list, filtered ready, or default ready
  # -----------------------------------------------------------------------
  bead_id=""
  bead_title=""
  bead_type=""

  if [[ "$EXPLICIT_MODE" == true ]]; then
    # Explicit bead list — stop when exhausted
    if [[ -z "$BEAD_IDS" ]]; then
      break
    fi

    if [[ "$RESPECT_DEPS" == true ]]; then
      # Scan the list for the first bead whose dependencies are all closed.
      # Beads that are still blocked get re-queued at the end.
      remaining=""
      found=false

      IFS=',' read -ra candidates <<< "$BEAD_IDS"
      for candidate in "${candidates[@]}"; do
        if [[ "$found" == true ]]; then
          # Already picked one — keep the rest as-is
          remaining="${remaining:+$remaining,}$candidate"
          continue
        fi

        if grep -qxF "$candidate" "$SKIP_FILE" 2>/dev/null; then
          continue   # failed earlier — drop from list
        fi

        # Check if all dependencies are closed
        dep_json=$(bd show "$candidate" --json 2>/dev/null) || dep_json="[]"
        open_deps=$(echo "$dep_json" | jq \
          '[.[0].dependencies // [] | .[] | select(.status != "closed")] | length')

        if [[ "$open_deps" -gt 0 ]]; then
          # Still blocked — re-queue at the end
          remaining="${remaining:+$remaining,}$candidate"
        else
          # Ready to go
          bead_id="$candidate"
          bead_title=$(bead_field "$dep_json" title unknown)
          bead_type=$(bead_field "$dep_json" issue_type task)
          found=true
        fi
      done

      BEAD_IDS="$remaining"

      if [[ "$found" == false ]]; then
        if [[ -n "$remaining" ]]; then
          echo ""
          log "All remaining beads are blocked. Stopping."
          log "  Blocked: ${remaining//,/, }"
        fi
        break
      fi
    else
      # No dep checking — pop first ID from the comma-separated list
      bead_id="${BEAD_IDS%%,*}"
      rest="${BEAD_IDS#*,}"
      [[ "$rest" == "$bead_id" ]] && rest=""   # was the last item
      BEAD_IDS="$rest"

      if grep -qxF "$bead_id" "$SKIP_FILE" 2>/dev/null; then
        continue   # already failed — skip silently
      fi

      # Resolve title/type from bd show
      bead_json=$(bd show "$bead_id" --json 2>/dev/null) || bead_json="[]"
      bead_title=$(bead_field "$bead_json" title unknown)
      bead_type=$(bead_field "$bead_json" issue_type task)
    fi
  else
    # Default mode — ask bd ready with passthrough filters
    ready_args=(--json)
    [[ -n "$FILTER_LABEL" ]]    && ready_args+=(--label "$FILTER_LABEL")
    [[ -n "$FILTER_TYPE" ]]     && ready_args+=(--type "$FILTER_TYPE")
    [[ -n "$FILTER_PRIORITY" ]] && ready_args+=(--priority "$FILTER_PRIORITY")
    [[ -n "$FILTER_OWNER" ]]    && ready_args+=(--assignee "$FILTER_OWNER")

    log "  bd ready ${ready_args[*]}"
    ready_json=$(bd ready "${ready_args[@]}" 2>/dev/null) || ready_json="[]"

    # Pick first not already skipped
    count=$(echo "$ready_json" | jq 'length')
    log "  Found $count candidate(s)"
    for i in $(seq 0 $((count - 1))); do
      candidate=$(echo "$ready_json" | jq -r ".[$i].id")
      if ! grep -qxF "$candidate" "$SKIP_FILE" 2>/dev/null; then
        bead_id="$candidate"
        bead_title=$(echo "$ready_json" | jq -r ".[$i].title")
        bead_type=$(echo "$ready_json" | jq -r ".[$i].issue_type")
        break
      fi
    done
  fi

  if [[ -z "$bead_id" ]]; then
    echo ""
    log "${C_GREEN}${C_BOLD}No more ready beads. Ralph is done.${C_RESET}"
    break
  fi

  iteration=$((iteration + 1))
  if [[ $iteration -gt $MAX_ITERATIONS ]]; then
    echo ""
    log "Reached max iterations ($MAX_ITERATIONS). Stopping."
    exit 1
  fi

  echo ""
  divider
  log "${C_BOLD}${C_WHITE}ITERATION $iteration: $bead_id${C_RESET} — ${C_CYAN}$bead_title${C_RESET}"
  divider

  # Claim the bead
  bd update "$bead_id" --status=in_progress 2>/dev/null || true

  # -----------------------------------------------------------------------
  # Build the prompt — fresh context each time (core Ralph insight)
  # -----------------------------------------------------------------------
  bead_details=$(bd show "$bead_id" 2>/dev/null)
  bead_show_json=$(bd show "$bead_id" --json 2>/dev/null) || bead_show_json="[]"
  acceptance=$(echo "$bead_show_json" | jq -r '.[0].acceptance_criteria // empty')
  bead_labels=$(echo "$bead_show_json" | jq -r '.[0].labels // [] | map("-l " + .) | join(" ")') || bead_labels=""
  prompt_file=$(mktemp /tmp/ralph-prompt.XXXXXX)

  (
    export BEAD_LABELS="$bead_labels" BEAD_ID="$bead_id"
    export PROJECT_RULES="$project_rules" BEAD_DETAILS="$bead_details"
    export ACCEPTANCE="$acceptance"
    render_prompt "$PROMPTS_DIR/worker.md" BEAD_LABELS BEAD_ID PROJECT_RULES BEAD_DETAILS ACCEPTANCE
  ) > "$prompt_file"

  # -----------------------------------------------------------------------
  # Run Claude — retry on failure
  # -----------------------------------------------------------------------
  log_file="$LOG_DIR/iter-${iteration}-${bead_id}.log"
  retries=0
  success=false

  while [[ $retries -lt $MAX_RETRIES ]]; do
    phase "$C_BLUE" "WORKER (attempt $((retries + 1))/$MAX_RETRIES) — $WORKER_MODEL"
    log "  ${C_DIM}Log: $log_file${C_RESET}"
    claude_as "$WORKER_MODEL" --output-format stream-json --verbose \
      < "$prompt_file" 2>&1 \
      | tee "$log_file" \
      | ralph_stream_filter || true

    # Check success from the stream-json result event (not pipeline exit code)
    extract_cost "worker" "$log_file"
    if jq -e 'select(.type == "result" and .subtype == "success")' "$log_file" > /dev/null 2>&1; then
      success=true
      break
    fi

    retries=$((retries + 1))
    if [[ $retries -lt $MAX_RETRIES ]]; then
      log "  ${C_YELLOW}Worker failed. Retrying in 5s...${C_RESET}"
      sleep 5
    fi
  done

  rm -f "$prompt_file"

  if [[ "$success" == false ]]; then
    log "  ${C_RED}Failed after $MAX_RETRIES attempts. Skipping $bead_id.${C_RESET}"
    echo "$bead_id" >> "$SKIP_FILE"
    bd update "$bead_id" --status=open 2>/dev/null || true   # release claim
    continue
  fi

  # -----------------------------------------------------------------------
  # Commit code + beads changes together.
  # .ralph-logs/ is script-internal and excluded.
  # Exclude pathspecs (:!) don't play well with git add, so we use
  # add-then-reset instead.
  # -----------------------------------------------------------------------
  if has_code_changes; then
    phase "$C_YELLOW" "COMMIT — $COMMIT_MODEL"
    commit_log="$LOG_DIR/iter-${iteration}-${bead_id}-commit.log"
    claude_as "$COMMIT_MODEL" -p "$(
      export BEAD_ID="$bead_id"
      render_prompt "$PROMPTS_DIR/commit.md" BEAD_ID
    )" 2>&1 | tee "$commit_log" && log "  ${C_GREEN}Committed.${C_RESET}" || log "  ${C_RED}Commit agent failed.${C_RESET} See $commit_log"
  else
    log "  ${C_DIM}No code changes to commit.${C_RESET}"
  fi

  # -----------------------------------------------------------------------
  # Review the work — fresh Claude instance, read-only
  # -----------------------------------------------------------------------
  phase "$C_MAGENTA" "REVIEW — $REVIEWER_MODEL"
  review_log="$LOG_DIR/iter-${iteration}-${bead_id}-review.log"

  claude_as "$REVIEWER_MODEL" --output-format stream-json --verbose -p "$(
    export BEAD_DETAILS="$bead_details" BEAD_ID="$bead_id"
    export PRE_LOOP_HEAD="$PRE_LOOP_HEAD" BEAD_LABELS="$bead_labels"
    render_prompt "$PROMPTS_DIR/review.md" BEAD_DETAILS BEAD_ID PRE_LOOP_HEAD BEAD_LABELS
  )" 2>&1 | tee "$review_log" | ralph_stream_filter || log "  ${C_RED}Review failed.${C_RESET} See $review_log"

  extract_cost "reviewer" "$review_log"
  review_result=$(jq -r 'select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text' "$review_log" 2>/dev/null | tail -1)
  if [[ "$review_result" == *"REVIEW_PASS"* ]]; then
    log "  ${C_GREEN}Review: PASS${C_RESET}"
  elif [[ "$review_result" == *"REVIEW_ISSUES_FILED"* ]]; then
    log "  ${C_YELLOW}Review: ISSUES FILED${C_RESET}"
  else
    log "  Review: ${review_result:-(no verdict)}"
  fi

  # -----------------------------------------------------------------------
  # Close the bead (or release if blocked)
  # -----------------------------------------------------------------------
  open_blockers=$(bd dep list "$bead_id" --json 2>/dev/null \
    | jq '[.[] | select(.status != "closed")] | length' 2>/dev/null) || open_blockers=0

  if [[ "$open_blockers" -gt 0 ]]; then
    log "  ${C_YELLOW}$bead_id has $open_blockers open blocker(s) — releasing claim.${C_RESET}"
    bd update "$bead_id" --status=open 2>/dev/null || true
  else
    bd close "$bead_id" --reason="Completed by ralph (iteration $iteration)" 2>/dev/null || true
    log "  ${C_GREEN}Closed $bead_id.${C_RESET}"
  fi

  bd_sync

  divider
  log "${C_GREEN}${C_BOLD}DONE: $bead_id${C_RESET}"
  divider
  sleep 2
done

# ---------------------------------------------------------------------------
# Wrap up
# ---------------------------------------------------------------------------
bd_sync

# Restore shelved untracked files
if [[ -n "$STASH_DIR" && -d "$STASH_DIR" ]]; then
  cp -a "$STASH_DIR"/. . 2>/dev/null || true
  rm -rf "$STASH_DIR"
  log "Restored shelved untracked files."
fi

echo ""
divider
log "Ralph Loop completed after $iteration iteration(s)."
if [[ -s "$SKIP_FILE" ]]; then
  echo ""
  log "Skipped beads (failed after retries):"
  while IFS= read -r id; do echo "  - $id"; done < "$SKIP_FILE"
fi
log "Logs: $LOG_DIR/"

# ---------------------------------------------------------------------------
# Post-loop test gate
# ---------------------------------------------------------------------------
test_output=""
test_passed=true
if [[ -n "$TEST_CMD" && $iteration -gt 0 ]]; then
  echo ""
  phase "$C_CYAN" "TEST GATE"
  test_log="$LOG_DIR/test-gate-$(date '+%H%M%S').log"
  log "Running: $TEST_CMD"

  if eval "$TEST_CMD" > "$test_log" 2>&1; then
    log "  ${C_GREEN}Tests: PASS${C_RESET}"
  else
    test_passed=false
    log "  ${C_RED}Tests: FAIL${C_RESET} See $test_log"
    bd create "Fix: test suite failures after ralph session" -t bug -p 1 \
      ${FILTER_LABEL:+-l "$FILTER_LABEL"} \
      -d "Test command '$TEST_CMD' failed after ralph session. See log: $test_log" \
      --acceptance "Running '$TEST_CMD' passes" --silent 2>/dev/null || true
    bd sync 2>/dev/null || true
  fi
  test_output=$(tail -100 "$test_log" 2>/dev/null)
fi

# ---------------------------------------------------------------------------
# Diff stats + final review personas
# ---------------------------------------------------------------------------
final_review_failed=false

if [[ $iteration -gt 0 ]]; then
  echo ""
  log "Session diff stats:"
  git diff --stat "$PRE_LOOP_HEAD"..HEAD

  # Build plan context — from --from-plan flag or PLAN.md in repo
  plan_context=""
  if [[ -n "${plan_body:-}" ]]; then
    plan_context="## Original Plan
# ${plan_title}
${plan_body}"
  elif [[ -f "PLAN.md" ]]; then
    plan_context="## Original Plan (from PLAN.md)
$(cat PLAN.md)"
  fi

  echo ""
  phase "$C_MAGENTA" "FINAL REVIEW — parallel personas ($FINAL_REVIEW_MODEL)"

  closed_beads=""
  if [[ -n "${FILTER_LABEL:-}" ]]; then
    closed_beads=$(bd list --label "$FILTER_LABEL" --status closed --json --limit 0 2>/dev/null) || closed_beads="[]"
  fi
  skipped=""; [[ -s "$SKIP_FILE" ]] && skipped=$(cat "$SKIP_FILE")

  test_context=""
  if [[ -n "$TEST_CMD" ]]; then
    if [[ "$test_passed" == true ]]; then
      test_context="## Test Results
Tests passed ('$TEST_CMD')."
    else
      test_context="## Test Results — FAILED
Command: $TEST_CMD
Output (last 100 lines):
${test_output}"
    fi
  fi

  bead_labels_flag="${FILTER_LABEL:+-l $FILTER_LABEL}"

  # --- Persona A: Security Reviewer ---
  sec_log="$LOG_DIR/final-review-security-$(date '+%H%M%S').log"
  claude_as "$FINAL_REVIEW_MODEL" --output-format stream-json --verbose -p "$(
    export PRE_LOOP_HEAD="$PRE_LOOP_HEAD" BEAD_LABELS_FLAG="$bead_labels_flag"
    export TEST_CONTEXT="$test_context"
    render_prompt "$PROMPTS_DIR/final-review-security.md" PRE_LOOP_HEAD BEAD_LABELS_FLAG TEST_CONTEXT
  )" 2>&1 | tee "$sec_log" | ralph_stream_filter &
  sec_pid=$!

  # --- Persona B: Integration Reviewer ---
  int_log="$LOG_DIR/final-review-integration-$(date '+%H%M%S').log"
  claude_as "$FINAL_REVIEW_MODEL" --output-format stream-json --verbose -p "$(
    export PRE_LOOP_HEAD="$PRE_LOOP_HEAD" BEAD_LABELS_FLAG="$bead_labels_flag"
    export TEST_CONTEXT="$test_context"
    render_prompt "$PROMPTS_DIR/final-review-integration.md" PRE_LOOP_HEAD BEAD_LABELS_FLAG TEST_CONTEXT
  )" 2>&1 | tee "$int_log" | ralph_stream_filter &
  int_pid=$!

  # --- Persona C: Codebase Patterns Reviewer ---
  pat_log="$LOG_DIR/final-review-patterns-$(date '+%H%M%S').log"
  claude_as "$FINAL_REVIEW_MODEL" --output-format stream-json --verbose -p "$(
    export PRE_LOOP_HEAD="$PRE_LOOP_HEAD" BEAD_LABELS_FLAG="$bead_labels_flag"
    export TEST_CONTEXT="$test_context"
    render_prompt "$PROMPTS_DIR/final-review-patterns.md" PRE_LOOP_HEAD BEAD_LABELS_FLAG TEST_CONTEXT
  )" 2>&1 | tee "$pat_log" | ralph_stream_filter &
  pat_pid=$!

  # --- Persona D: Plan Adherence Reviewer (conditional) ---
  plan_pid=""
  plan_log=""
  if [[ -n "$plan_context" ]]; then
    plan_log="$LOG_DIR/final-review-plan-$(date '+%H%M%S').log"
    claude_as "$FINAL_REVIEW_MODEL" --output-format stream-json --verbose -p "$(
      export PRE_LOOP_HEAD="$PRE_LOOP_HEAD" BEAD_LABELS_FLAG="$bead_labels_flag"
      export TEST_CONTEXT="$test_context"
      export PLAN_CONTEXT="$plan_context"
      render_prompt "$PROMPTS_DIR/final-review-plan.md" PRE_LOOP_HEAD BEAD_LABELS_FLAG TEST_CONTEXT PLAN_CONTEXT
    )" 2>&1 | tee "$plan_log" | ralph_stream_filter &
    plan_pid=$!
  fi

  # Wait for all final reviewers
  wait "$sec_pid" "$int_pid" "$pat_pid" ${plan_pid:+"$plan_pid"} 2>/dev/null || true

  # Collect results
  for logvar in sec_log int_log pat_log ${plan_context:+plan_log}; do
    logfile="${!logvar}"
    [[ -z "$logfile" || ! -f "$logfile" ]] && continue
    label=$(basename "$logfile" .log | sed 's/final-review-//' | sed 's/-[0-9]*//')
    extract_cost "final-$label" "$logfile"
    result=$(jq -r 'select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text' "$logfile" 2>/dev/null | tail -1)
    if [[ "$result" == *"_PASS"* ]]; then
      log "  ${C_GREEN}${label}: PASS${C_RESET}"
    elif [[ "$result" == *"_ISSUES"* ]]; then
      log "  ${C_YELLOW}${label}: ISSUES FILED${C_RESET}"
      final_review_failed=true
    else
      log "  ${label}: ${result:-(no verdict)}"
    fi
  done
fi

# ---------------------------------------------------------------------------
# Post-run summary — read all work logs and extract learnings
# ---------------------------------------------------------------------------
if [[ $iteration -gt 0 ]]; then
  echo ""
  log "Generating run summary..."
  summary_file="$LOG_DIR/summary-$(date '+%Y%m%d-%H%M%S').md"

  # Collect work logs (skip commit logs)
  log_list=""
  for f in "$LOG_DIR"/iter-*; do
    [[ "$f" == *-commit.log ]] && continue
    [[ -f "$f" ]] && log_list="$log_list $f"
  done

  if [[ -n "$log_list" ]]; then
    claude_as "$SUMMARY_MODEL" -p "$(
      export LOG_LIST="$log_list" SKIP_FILE="$SKIP_FILE"
      export GENERATED_TS="$(date '+%Y-%m-%d %H:%M:%S')"
      render_prompt "$PROMPTS_DIR/summary.md" LOG_LIST SKIP_FILE GENERATED_TS
    )" > "$summary_file" 2>&1

    echo ""
    cat "$summary_file"
    echo ""
    log "(saved to $summary_file)"
  fi
fi

# ---------------------------------------------------------------------------
# Cost report
# ---------------------------------------------------------------------------
if [[ "${AGENT_COSTS[@]+x}" ]]; then
  echo ""
  log "Cost breakdown:"
  total=0
  for agent_type in "${!AGENT_COSTS[@]}"; do
    cost="${AGENT_COSTS[$agent_type]}"
    printf "  %-20s \$%s\n" "$agent_type" "$cost"
    total=$(echo "$total + $cost" | bc 2>/dev/null || echo "$total")
  done
  printf "  %-20s \$%s\n" "TOTAL" "$total"
fi

# ---------------------------------------------------------------------------
# Exit code — non-zero if final review found issues or tests failed
# ---------------------------------------------------------------------------
if [[ "${final_review_failed:-false}" == true ]] || [[ "${test_passed:-true}" == false ]]; then
  exit 1
fi
