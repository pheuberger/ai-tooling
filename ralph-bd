#!/usr/bin/env bash
# ralph-bd.sh — Ralph Loop for beads-driven autonomous coding
#
# Spawns a fresh Claude Code instance per ready bead. Each instance gets
# clean context — no conversation history carries over. State lives in
# the filesystem and git, not in the LLM's memory. This sidesteps context
# degradation by treating every iteration as a brand-new session.
#
# Usage: ./ralph-bd [options]
#   --max-iterations N   Maximum total iterations (default: 50)
#   --max-retries N      Retries per bead on failure (default: 3)
#   --model MODEL        Force ALL agents to this model (overrides per-agent models)
#   --beads ID[,ID,...]  Only process these beads, in order (skip bd ready)
#   --parent ID          Scope to children of this epic/feature (filters bd ready via --label)
#   --respect-deps       With --beads: skip beads whose dependencies aren't closed yet
#   --type TYPE          Filter ready beads by issue_type (feature|bug|task)
#   --priority N         Only pick beads with priority <= N (0=critical … 4=backlog)
#   --owner NAME         Only pick beads owned by NAME
#   --label LABEL        Filter ready beads by label
#   --from-plan FILE     Decompose a plan file into an epic + tasks, then work them
#
# Configuration files (optional):
#   .ralphrc             Sourced from project root before CLI args are parsed.
#                        Set any of: MAX_ITERATIONS, MAX_RETRIES, MODEL,
#                        WORKER_MODEL, REVIEWER_MODEL, COMMIT_MODEL,
#                        LEAD_MODEL, SPEC_MODEL, SUMMARY_MODEL,
#                        FILTER_TYPE, FILTER_PRIORITY, FILTER_OWNER,
#                        FILTER_LABEL, LOG_DIR, RALPH_RULES_FILE.
#                        CLI flags override values set here.
#   .ralph-rules.md      Extra instructions injected into the agent prompt as a
#                        "## Project Rules" section. Use for ralph-specific rules
#                        that don't belong in AGENTS.md or CLAUDE.md. Silently
#                        skipped if absent. Path configurable via RALPH_RULES_FILE.
#
# Requires: claude (Claude Code CLI), bd (beads), jq, git
#
# References:
#   https://github.com/snarktank/ralph
#   https://medium.com/@tentenco/what-is-ralph-loop-a-new-era-of-autonomous-coding-96a4bb3e2ac8

set -euo pipefail

# Colors
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'
C_CYAN='\033[36m'
C_GREEN='\033[32m'
C_YELLOW='\033[33m'
C_MAGENTA='\033[35m'
C_BLUE='\033[34m'
C_RED='\033[31m'
C_WHITE='\033[97m'

ts()         { printf '%s' "$(date '+%Y-%m-%d %H:%M:%S')"; }
log()        { echo -e "${C_DIM}[$(ts)]${C_RESET} $*"; }
bd_sync()    { bd sync 2>/dev/null || true; }
bead_field() { echo "$1" | jq -r ".[0].$2 // \"$3\""; }
phase()      { echo -e "\n${C_BOLD}${1}--- ${2} ---${C_RESET}"; }
divider()    { echo -e "${C_DIM}$(printf '%.0s─' {1..65})${C_RESET}"; }

# True if there are unstaged, staged, or untracked changes outside .beads/ and .ralph-logs/
has_code_changes() {
  git diff --quiet -- ':!.beads' ':!.ralph-logs' 2>/dev/null            || return 0
  git diff --cached --quiet -- ':!.beads' ':!.ralph-logs' 2>/dev/null   || return 0
  [[ -z "$(git ls-files --others --exclude-standard -- ':!.beads' ':!.ralph-logs' 2>/dev/null)" ]] || return 0
  return 1
}

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
MAX_ITERATIONS=50
MAX_RETRIES=3
MODEL=""              # global override — forces all agents to this model
LEAD_MODEL=""         # lead agent (plan decomposition) — default: opus
SPEC_MODEL=""         # spec reviewer — default: opus
WORKER_MODEL=""       # coding worker — default: sonnet
COMMIT_MODEL=""       # commit agent — default: haiku
REVIEWER_MODEL=""     # code reviewer — default: opus
SUMMARY_MODEL=""      # post-run summary — default: haiku
BEAD_IDS=""           # comma-separated explicit bead list (--beads mode only)
PARENT_ID=""          # parent bead ID — passed through to bd ready
EXPLICIT_MODE=false   # set when --beads is used (prevents fallback to bd ready)
RESPECT_DEPS=false    # with --beads: skip beads whose deps aren't closed
FILTER_TYPE=""        # filter by issue_type (feature|bug|task)
FILTER_PRIORITY=""    # only beads with priority <= this value (0=critical … 4=backlog)
FILTER_OWNER=""       # only beads owned by this name
FILTER_LABEL=""       # filter by label
PLAN_FILE=""          # --from-plan: plan file to decompose into beads
LOG_DIR=".ralph-logs"
RALPH_RULES_FILE=".ralph-rules.md"

# Source per-project config (CLI flags override)
if [[ -f ".ralphrc" ]]; then
  # shellcheck source=/dev/null
  source ".ralphrc"
fi

SKIP_FILE="$LOG_DIR/.skipped"

while [[ $# -gt 0 ]]; do
  case $1 in
    --max-iterations) MAX_ITERATIONS="$2"; shift 2 ;;
    --max-retries)    MAX_RETRIES="$2"; shift 2 ;;
    --model)          MODEL="$2"; shift 2 ;;
    --beads)          BEAD_IDS="$2"; EXPLICIT_MODE=true; shift 2 ;;
    --parent)         PARENT_ID="$2"; shift 2 ;;
    --respect-deps)   RESPECT_DEPS=true; shift ;;
    --type)           FILTER_TYPE="$2"; shift 2 ;;
    --priority)       FILTER_PRIORITY="$2"; shift 2 ;;
    --owner)          FILTER_OWNER="$2"; shift 2 ;;
    --label)          FILTER_LABEL="$2"; shift 2 ;;
    --from-plan)      PLAN_FILE="$2"; shift 2 ;;
    -h|--help)        sed -n '/^# Usage/,/^$/p' "$0" | sed 's/^# \?//'; exit 0 ;;
    *)                echo "Unknown option: $1" >&2; exit 1 ;;
  esac
done

# ---------------------------------------------------------------------------
# Validate mutually exclusive flags
# ---------------------------------------------------------------------------
if [[ -n "$PARENT_ID" && -n "$BEAD_IDS" ]]; then
  echo "Cannot use --parent and --beads together." >&2; exit 1
fi

# Read plan file early — before untracked-file stashing moves it away
plan_title=""
plan_body=""
if [[ -n "$PLAN_FILE" ]]; then
  if [[ ! -f "$PLAN_FILE" ]]; then
    echo "Plan file not found: $PLAN_FILE" >&2; exit 1
  fi
  plan_title=$(head -1 "$PLAN_FILE" | sed 's/^#* *//')
  plan_body=$(tail -n +2 "$PLAN_FILE")
fi

# ---------------------------------------------------------------------------
# Preflight
# ---------------------------------------------------------------------------
for cmd in claude bd jq git; do
  command -v "$cmd" >/dev/null 2>&1 || { echo "Required: $cmd" >&2; exit 1; }
done

git diff --quiet --cached 2>/dev/null || { echo "Staged changes exist. Commit or stash first." >&2; exit 1; }

# Move pre-existing untracked files (PLAN.md, SPEC.md, etc.) out of the
# working tree so git add -A inside the loop doesn't pick them up.
# We can't use git stash because it would also revert unstaged tracked
# changes in .beads/, breaking bd ready.
STASH_DIR=""
untracked=$(git ls-files --others --exclude-standard -- ':!.beads' ':!.ralph-logs' 2>/dev/null)
if [[ -n "$untracked" ]]; then
  STASH_DIR=$(mktemp -d /tmp/ralph-stash.XXXXXX)
  echo "$untracked" | while IFS= read -r f; do
    mkdir -p "$STASH_DIR/$(dirname "$f")"
    mv "$f" "$STASH_DIR/$f"
  done
  log "Shelved $(echo "$untracked" | wc -l | tr -d ' ') untracked file(s) to $STASH_DIR"
fi

mkdir -p "$LOG_DIR"
: > "$SKIP_FILE"

# Stream filter — extracts readable progress from stream-json output
ralph_stream_filter() {
  jq --unbuffered -r '
    if .type == "assistant" then
      [.message.content[]? |
        if .type == "text" then .text
        elif .type == "tool_use" then
          (.input // {}) as $in |
          (.name as $n |
            if   $n == "Bash"   then $in.command // ""
            elif $n == "Edit"   then $in.file_path // ""
            elif $n == "Read"   then $in.file_path // ""
            elif $n == "Write"  then $in.file_path // ""
            elif $n == "Grep"   then ($in.pattern // "") + " " + ($in.path // "")
            elif $n == "Glob"   then $in.pattern // ""
            else "" end
          ) as $detail |
          "\u001b[36m>>> " + .name + "\u001b[2m " + ($detail | .[0:120]) + "\u001b[0m"
        else empty end
      ] | join("\n") | select(length > 0)
    elif .type == "result" then
      "\u001b[2m--- " + .subtype + " | " + (.duration_ms | tostring) + "ms | $" + (.total_cost_usd | tostring) + " ---\u001b[0m"
    else empty end
  ' 2>/dev/null
}

iteration=0

# Common claude flags — shared by all agent invocations
claude_flags=(--print --dangerously-skip-permissions)

# Per-agent model defaults — global MODEL overrides everything
LEAD_MODEL="${MODEL:-${LEAD_MODEL:-claude-opus-4-6}}"
SPEC_MODEL="${MODEL:-${SPEC_MODEL:-claude-opus-4-6}}"
WORKER_MODEL="${MODEL:-${WORKER_MODEL:-claude-sonnet-4-5-20250929}}"
COMMIT_MODEL="${MODEL:-${COMMIT_MODEL:-claude-haiku-4-5-20251001}}"
REVIEWER_MODEL="${MODEL:-${REVIEWER_MODEL:-claude-opus-4-6}}"
SUMMARY_MODEL="${MODEL:-${SUMMARY_MODEL:-claude-haiku-4-5-20251001}}"

# Run claude with a specific model: claude_as <model> [extra-args...]
claude_as() {
  local model="$1"; shift
  claude "${claude_flags[@]}" --model "$model" "$@"
}

log "Ralph Loop starting (max_iterations=$MAX_ITERATIONS, max_retries=$MAX_RETRIES)"
log_opt() { [[ -n "${2:-}" ]] && log "  $1: $2" || true; }
[[ -f ".ralphrc" ]]          && log "  Config: .ralphrc loaded"
[[ -f "$RALPH_RULES_FILE" ]] && log "  Rules: $RALPH_RULES_FILE loaded"
log_opt "Plan"            "$PLAN_FILE"
log_opt "Parent"          "$PARENT_ID"
log_opt "Beads"           "$BEAD_IDS"
log_opt "Filter type"     "$FILTER_TYPE"
log_opt "Filter priority" "${FILTER_PRIORITY:+<= $FILTER_PRIORITY}"
log_opt "Filter owner"    "$FILTER_OWNER"
log_opt "Filter label"    "$FILTER_LABEL"
[[ "$RESPECT_DEPS" == true ]] && log "  Respect deps: yes (blocked beads deferred)" || true
if [[ -n "$MODEL" ]]; then
  log "  Model (all agents): $MODEL"
else
  log "  Models: worker=$WORKER_MODEL  reviewer=$REVIEWER_MODEL  commit=$COMMIT_MODEL"
  [[ -n "$PLAN_FILE" ]] && log "          lead=$LEAD_MODEL  spec=$SPEC_MODEL" || true
  log "          summary=$SUMMARY_MODEL"
fi
divider

# Load project-specific rules once (injected into worker prompts)
project_rules=""
[[ -f "$RALPH_RULES_FILE" ]] && project_rules=$(<"$RALPH_RULES_FILE")

# ---------------------------------------------------------------------------
# --from-plan: decompose a plan file into beads, then fall through to loop
# ---------------------------------------------------------------------------
if [[ -n "$PLAN_FILE" ]]; then
  # plan_title and plan_body were read before stashing (see above)

  # Create the epic in bd — ralph owns this, not the agent
  PARENT_ID=$(bd create "$plan_title" -t epic -d "$plan_body" --silent)
  bd_sync
  log "Created epic $PARENT_ID: $plan_title"

  # --- Phase 1: Decompose epic into tasks ---
  log "Lead: decomposing into tasks..."
  lead_log="$LOG_DIR/lead-$(date '+%H%M%S').log"

  claude_as "$LEAD_MODEL" -p "$(cat <<LEAD_PROMPT
You are a lead agent decomposing an epic into implementable tasks.
Do NOT write implementation code. Your job is planning only.

## Epic: ${plan_title}
${plan_body}

## Instructions
Break this into small, independently implementable child tasks using bd create.
Each task will be worked on by a separate Claude Code instance with NO shared context.

For each task:
  bd create "<title>" -t task --parent ${PARENT_ID} \\
    -d "<self-contained description: file paths, function names, expected behavior, edge cases>" \\
    --acceptance "<binary pass/fail verification: a command to run, or a specific check>" \\
    -e <minutes> -l scope:small -l ${PARENT_ID} --silent

Set dependencies only where ordering truly matters:
  bd dep <blocker-id> --blocks <blocked-id>

After creating all tasks: bd sync

Each task must be completable in under 30 minutes by a fresh agent with zero prior context.
If you can't define binary acceptance criteria, break the task smaller.
LEAD_PROMPT
  )" > "$lead_log" 2>&1
  bd_sync
  log "Lead: done. See $lead_log"

  # --- Phase 2: Validate specs ---
  log "Validating specs..."
  spec_log="$LOG_DIR/spec-review-$(date '+%H%M%S').log"
  children_json=$(bd list --parent "$PARENT_ID" --status open --json --limit 0 2>/dev/null) || children_json="[]"

  claude_as "$SPEC_MODEL" -p "$(cat <<SPEC_PROMPT
You are a spec reviewer. Validate that each task under this epic is ready for a worker agent.

## Tasks
${children_json}

## Checks per task
1. Description is self-contained (a fresh agent with no context can implement it)
2. File paths and function names are specified
3. Acceptance criteria exist and are binary pass/fail
4. No implicit dependencies on other tasks that aren't declared

## Actions
- If a task fails validation, fix it: bd update <id> -d "<improved description>" --acceptance "<improved criteria>"
- If a task is too large, split it: bd close <id> --reason "split" then create smaller tasks
- After all fixes: bd sync

Output a one-line summary per task: PASS or what you fixed.
SPEC_PROMPT
  )" > "$spec_log" 2>&1
  bd_sync
  log "Spec review: done. See $spec_log"

  # PARENT_ID is set — fall through into the main worker+reviewer loop
fi

# ---------------------------------------------------------------------------
# Main loop — runs as long as there are unblocked beads
# ---------------------------------------------------------------------------
while true; do
  # -----------------------------------------------------------------------
  # Pick next bead — explicit list, filtered ready, or default ready
  # -----------------------------------------------------------------------
  bead_id=""
  bead_title=""
  bead_type=""

  if [[ "$EXPLICIT_MODE" == true ]]; then
    # Explicit bead list — stop when exhausted
    if [[ -z "$BEAD_IDS" ]]; then
      break
    fi

    if [[ "$RESPECT_DEPS" == true ]]; then
      # Scan the list for the first bead whose dependencies are all closed.
      # Beads that are still blocked get re-queued at the end.
      remaining=""
      found=false

      IFS=',' read -ra candidates <<< "$BEAD_IDS"
      for candidate in "${candidates[@]}"; do
        if [[ "$found" == true ]]; then
          # Already picked one — keep the rest as-is
          remaining="${remaining:+$remaining,}$candidate"
          continue
        fi

        if grep -qxF "$candidate" "$SKIP_FILE" 2>/dev/null; then
          continue   # failed earlier — drop from list
        fi

        # Check if all dependencies are closed (exclude parent bead — it blocks
        # all children structurally, not as an ordering constraint)
        dep_json=$(bd show "$candidate" --json 2>/dev/null) || dep_json="[]"
        open_deps=$(echo "$dep_json" | jq --arg parent "$PARENT_ID" \
          '[.[0].dependencies // [] | .[] | select(.status != "closed" and .id != $parent)] | length')

        if [[ "$open_deps" -gt 0 ]]; then
          # Still blocked — re-queue at the end
          remaining="${remaining:+$remaining,}$candidate"
        else
          # Ready to go
          bead_id="$candidate"
          bead_title=$(bead_field "$dep_json" title unknown)
          bead_type=$(bead_field "$dep_json" issue_type task)
          found=true
        fi
      done

      BEAD_IDS="$remaining"

      if [[ "$found" == false ]]; then
        if [[ -n "$remaining" ]]; then
          echo ""
          log "All remaining beads are blocked. Stopping."
          log "  Blocked: ${remaining//,/, }"
        fi
        break
      fi
    else
      # No dep checking — pop first ID from the comma-separated list
      bead_id="${BEAD_IDS%%,*}"
      rest="${BEAD_IDS#*,}"
      [[ "$rest" == "$bead_id" ]] && rest=""   # was the last item
      BEAD_IDS="$rest"

      if grep -qxF "$bead_id" "$SKIP_FILE" 2>/dev/null; then
        continue   # already failed — skip silently
      fi

      # Resolve title/type from bd show
      bead_json=$(bd show "$bead_id" --json 2>/dev/null) || bead_json="[]"
      bead_title=$(bead_field "$bead_json" title unknown)
      bead_type=$(bead_field "$bead_json" issue_type task)
    fi
  else
    # Default mode — ask bd ready with passthrough filters
    ready_args=(--json)
    [[ -n "$PARENT_ID" ]]       && ready_args+=(--label "$PARENT_ID")
    [[ -n "$FILTER_LABEL" ]]    && ready_args+=(--label "$FILTER_LABEL")
    [[ -n "$FILTER_TYPE" ]]     && ready_args+=(--type "$FILTER_TYPE")
    [[ -n "$FILTER_PRIORITY" ]] && ready_args+=(--priority "$FILTER_PRIORITY")
    [[ -n "$FILTER_OWNER" ]]    && ready_args+=(--assignee "$FILTER_OWNER")

    log "  bd ready ${ready_args[*]}"
    ready_json=$(bd ready "${ready_args[@]}" 2>/dev/null) || ready_json="[]"

    # Pick first not already skipped
    count=$(echo "$ready_json" | jq 'length')
    log "  Found $count candidate(s)"
    for i in $(seq 0 $((count - 1))); do
      candidate=$(echo "$ready_json" | jq -r ".[$i].id")
      if [[ -n "$PARENT_ID" && "$candidate" == "$PARENT_ID" ]]; then
        log "  Skipping parent $candidate"
        continue
      fi
      if ! grep -qxF "$candidate" "$SKIP_FILE" 2>/dev/null; then
        bead_id="$candidate"
        bead_title=$(echo "$ready_json" | jq -r ".[$i].title")
        bead_type=$(echo "$ready_json" | jq -r ".[$i].issue_type")
        break
      fi
    done
  fi

  if [[ -z "$bead_id" ]]; then
    echo ""
    log "${C_GREEN}${C_BOLD}No more ready beads. Ralph is done.${C_RESET}"
    break
  fi

  iteration=$((iteration + 1))
  if [[ $iteration -gt $MAX_ITERATIONS ]]; then
    echo ""
    log "Reached max iterations ($MAX_ITERATIONS). Stopping."
    exit 1
  fi

  echo ""
  divider
  log "${C_BOLD}${C_WHITE}ITERATION $iteration: $bead_id${C_RESET} — ${C_CYAN}$bead_title${C_RESET}"
  divider

  # Claim the bead
  bd update "$bead_id" --status=in_progress 2>/dev/null || true

  # -----------------------------------------------------------------------
  # Build the prompt — fresh context each time (core Ralph insight)
  # -----------------------------------------------------------------------
  bead_details=$(bd show "$bead_id" 2>/dev/null)
  bead_show_json=$(bd show "$bead_id" --json 2>/dev/null) || bead_show_json="[]"
  acceptance=$(echo "$bead_show_json" | jq -r '.[0].acceptance_criteria // empty')
  bead_parent=$(echo "$bead_show_json" | jq -r '.[0].parent // empty')
  prompt_file=$(mktemp /tmp/ralph-prompt.XXXXXX)

  cat > "$prompt_file" <<__RALPH_PROMPT__
You are an autonomous coding agent working on a single task.
This is a fresh Claude Code instance — you have no prior conversation history.
State lives in the filesystem and git, not in your memory (Ralph Loop pattern).

## Rules
- Do NOT create git commits. The outer loop handles all commits.
- Do NOT close, update status, or sync beads. Bead lifecycle is managed externally.
- Do NOT use TodoWrite or TaskCreate for tracking.
- Focus ONLY on the task below. Do not work on anything else.
- If you are genuinely blocked (missing dependency, wrong spec, file doesn't exist), file a blocker and stop:
    NEW_ID=\$(bd create "Blocker: <description>" -t bug -p 1 --parent ${bead_parent:-$PARENT_ID} --silent)
    bd dep "\$NEW_ID" --blocks ${bead_id}
  Then explain what blocked you and stop working.
${project_rules:+
## Project Rules
$project_rules
}
## When you are done
End your output with a "## Learnings" section. Include ONLY things that were
unexpected or required a pivot from the spec — e.g. the spec said X but the
code actually needed Y, a dependency behaved differently than expected, a file
was structured differently than described, an edge case the spec didn't cover.
If everything went exactly as described, write "None — task matched spec."

## Task
${bead_details}
${acceptance:+
## Acceptance Criteria
$acceptance
Verify each criterion passes before you finish.
}
__RALPH_PROMPT__

  # -----------------------------------------------------------------------
  # Run Claude — retry on failure
  # -----------------------------------------------------------------------
  log_file="$LOG_DIR/iter-${iteration}-${bead_id}.log"
  retries=0
  success=false

  while [[ $retries -lt $MAX_RETRIES ]]; do
    phase "$C_BLUE" "WORKER (attempt $((retries + 1))/$MAX_RETRIES) — $WORKER_MODEL"
    log "  ${C_DIM}Log: $log_file${C_RESET}"
    claude_as "$WORKER_MODEL" --output-format stream-json --verbose \
      < "$prompt_file" 2>&1 \
      | tee "$log_file" \
      | ralph_stream_filter || true

    # Check success from the stream-json result event (not pipeline exit code)
    if jq -e 'select(.type == "result" and .subtype == "success")' "$log_file" > /dev/null 2>&1; then
      success=true
      break
    fi

    retries=$((retries + 1))
    if [[ $retries -lt $MAX_RETRIES ]]; then
      log "  ${C_YELLOW}Worker failed. Retrying in 5s...${C_RESET}"
      sleep 5
    fi
  done

  rm -f "$prompt_file"

  if [[ "$success" == false ]]; then
    log "  ${C_RED}Failed after $MAX_RETRIES attempts. Skipping $bead_id.${C_RESET}"
    echo "$bead_id" >> "$SKIP_FILE"
    bd update "$bead_id" --status=open 2>/dev/null || true   # release claim
    continue
  fi

  # -----------------------------------------------------------------------
  # Commit code changes only.
  # .beads/ is managed by bd sync. .ralph-logs/ is script-internal.
  # Exclude pathspecs (:!) don't play well with git add, so we use
  # add-then-reset instead.
  # -----------------------------------------------------------------------
  if has_code_changes; then
    phase "$C_YELLOW" "COMMIT — $COMMIT_MODEL"
    commit_log="$LOG_DIR/iter-${iteration}-${bead_id}-commit.log"
    claude_as "$COMMIT_MODEL" -p "$(cat <<__RALPH_COMMIT__
Stage and commit the current code changes.

Steps:
1. Run: git add -A && git reset HEAD -- .beads .ralph-logs
2. Run: git diff --cached (to see what you're committing)
3. Write a commit message that focuses on the *why* more than the *what*.
   Follow any commit conventions the project has (check CLAUDE.md, AGENTS.md).
   Include "(${bead_id})" at the end of the first line of the commit message.
4. Commit using a heredoc for the message.
5. If the commit fails due to lint-staged or husky, fix the reported issues and retry.
6. Do NOT run bd commands. Do NOT push.
__RALPH_COMMIT__
    )" 2>&1 | tee "$commit_log" && log "  ${C_GREEN}Committed.${C_RESET}" || log "  ${C_RED}Commit agent failed.${C_RESET} See $commit_log"
  else
    log "  ${C_DIM}No code changes to commit.${C_RESET}"
  fi

  # -----------------------------------------------------------------------
  # Review the work — fresh Claude instance, read-only
  # -----------------------------------------------------------------------
  phase "$C_MAGENTA" "REVIEW — $REVIEWER_MODEL"
  review_log="$LOG_DIR/iter-${iteration}-${bead_id}-review.log"

  claude_as "$REVIEWER_MODEL" -p "$(cat <<__RALPH_REVIEW__
You are a code reviewer. Review the implementation of this task.
Do NOT modify any code. Do NOT close or update bead status.

## Task
${bead_details}

## Instructions
1. Find what changed: git log --oneline -1 --grep="(${bead_id})" then git show <hash>.
   If no commit found, check the files mentioned in the task description.
2. Does the implementation match the spec and acceptance criteria?
3. Are there bugs, missing edge cases, or security issues?
4. If you find problems that need fixing, file each as a new bead:
   NEW_ID=\$(bd create "Fix: <problem> (from ${bead_id})" -t bug -p 2 \\
     --parent ${bead_parent:-$PARENT_ID} \\
     -d "<what's wrong and how to fix it>" \\
     --acceptance "<how to verify the fix>" --silent)
   Then run: bd sync
5. If everything looks good, output: REVIEW_PASS
6. If you filed fix beads, output: REVIEW_ISSUES_FILED
__RALPH_REVIEW__
  )" 2>&1 | tee "$review_log" || log "  ${C_RED}Review failed.${C_RESET} See $review_log"

  review_result=$(tail -1 "$review_log")
  if [[ "$review_result" == *"REVIEW_PASS"* ]]; then
    log "  ${C_GREEN}Review: PASS${C_RESET}"
  elif [[ "$review_result" == *"REVIEW_ISSUES_FILED"* ]]; then
    log "  ${C_YELLOW}Review: ISSUES FILED${C_RESET}"
  else
    log "  Review: $review_result"
  fi

  # -----------------------------------------------------------------------
  # Close the bead (or release if blocked)
  # -----------------------------------------------------------------------
  open_blockers=$(bd dep list "$bead_id" --json 2>/dev/null \
    | jq '[.[] | select(.status != "closed" and .dependency_type != "parent-child")] | length' 2>/dev/null) || open_blockers=0

  if [[ "$open_blockers" -gt 0 ]]; then
    log "  ${C_YELLOW}$bead_id has $open_blockers open blocker(s) — releasing claim.${C_RESET}"
    bd update "$bead_id" --status=open 2>/dev/null || true
  else
    bd close "$bead_id" --reason="Completed by ralph (iteration $iteration)" 2>/dev/null || true
    log "  ${C_GREEN}Closed $bead_id.${C_RESET}"
  fi

  bd_sync

  divider
  log "${C_GREEN}${C_BOLD}DONE: $bead_id${C_RESET}"
  divider
  sleep 2
done

# ---------------------------------------------------------------------------
# Wrap up
# ---------------------------------------------------------------------------
bd_sync

# Restore shelved untracked files
if [[ -n "$STASH_DIR" && -d "$STASH_DIR" ]]; then
  cp -a "$STASH_DIR"/. . 2>/dev/null || true
  rm -rf "$STASH_DIR"
  log "Restored shelved untracked files."
fi

echo ""
divider
log "Ralph Loop completed after $iteration iteration(s)."
if [[ -s "$SKIP_FILE" ]]; then
  echo ""
  log "Skipped beads (failed after retries):"
  while IFS= read -r id; do echo "  - $id"; done < "$SKIP_FILE"
fi
log "Logs: $LOG_DIR/"

# ---------------------------------------------------------------------------
# Post-run summary — read all work logs and extract learnings
# ---------------------------------------------------------------------------
if [[ $iteration -gt 0 ]]; then
  echo ""
  log "Generating run summary..."
  summary_file="$LOG_DIR/summary-$(date '+%Y%m%d-%H%M%S').md"

  # Collect work logs (skip commit logs)
  log_list=""
  for f in "$LOG_DIR"/iter-*; do
    [[ "$f" == *-commit.log ]] && continue
    [[ -f "$f" ]] && log_list="$log_list $f"
  done

  if [[ -n "$log_list" ]]; then
    claude_as "$SUMMARY_MODEL" -p "$(cat <<EOF
Read each of the following log files. They are outputs from autonomous coding
agents that each worked on a single task.

Log files: ${log_list}

Write a concise run summary to stdout. Start with a line: "Generated: $(date '+%Y-%m-%d %H:%M:%S')"
Then include these sections:

## Completed
One-line per bead: what was done.

## Learnings & Surprises
Extract anything from the agents' "## Learnings" sections (or from the body
of their output) that was unexpected — spec inaccuracies, pivots, edge cases,
dependency quirks, code structure that differed from expectations.
Group related items. Skip anything that was "None — task matched spec."

## Skipped / Failed
List any beads that failed (if the skip file at ${SKIP_FILE} is non-empty,
read it). Briefly note what went wrong if visible in the logs.

Keep it tight — this is a debrief, not a novel.
EOF
    )" > "$summary_file" 2>&1

    echo ""
    cat "$summary_file"
    echo ""
    log "(saved to $summary_file)"
  fi
fi
